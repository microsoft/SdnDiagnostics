function Install-SdnDiagnostics {
    <#
    .SYNOPSIS
        Install SdnDiagnostic Module to remote computers if not installed or version mismatch.
    .PARAMETER ComputerName
        Type the NetBIOS name, an IP address, or a fully qualified domain name of one or more remote computers.
    .PARAMETER Credential
        Specifies a user account that has permission to perform this action. The default is the current user.
        Type a user name, such as User01 or Domain01\User01, or enter a PSCredential object generated by the Get-Credential cmdlet. If you type a user name, you're prompted to enter the password.
    .PARAMETER Path
        Specifies the path to the module where it should be installed. If not specified, the default path will be used.
    .PARAMETER Force
        Forces a cleanup and re-install of the module on the remote computer.
    #>

    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.String[]]$ComputerName,

        [Parameter(Mandatory = $false)]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty,

        [Parameter(Mandatory = $false)]
        [System.String]$Path = $Script:SdnDiagnostics_Utilities.Config.DefaultModuleDirectory,

        [Parameter(Mandatory = $false)]
        [switch]$Force
    )

    # if we have configured automatic seeding of module to remote nodes, we will want to skip this operation
    if ($Global:SdnDiagnostics.Config.DisableModuleSeeding) {
        return
    }

    $moduleName = $Global:SdnDiagnostics.Config.ModuleName
    $filteredComputerName = [System.Collections.ArrayList]::new()
    $installNodes = [System.Collections.ArrayList]::new()

    try {
        # if we have multiple modules installed on the current workstation,
        # abort the operation because side by side modules can cause some interop issues to the remote nodes
        $localModule = Get-Module -Name 'SdnDiagnostics'
        if ($localModule.Count -gt 1) {
            throw "Detected more than one module version of SdnDiagnostics. Remove all versions of module from runspace and re-import the module."
        }

        # typically PowerShell modules will be installed in the following directory configuration:
        #    $env:ProgramFiles\WindowsPowerShell\Modules\SdnDiagnostics\{version}
        #    $env:USERPROFILE\Documents\WindowsPowerShell\Modules\SdnDiagnostics\{version}
        # so we default to Leaf of the path being SdnDiagnostics as PSGet will handle the versioning so we only ever do import in the following format:
        #    Import-Module SdnDiagnostics (if using default PowerShell module path)
        #    Import-Module C:\{path}\SdnDiagnostics (if using custom PowerShell module path)
        # so we need to ensure that we are copying the module to the correct path on the remote computer
        [System.String]$destinationPathDir = Join-Path $Path -ChildPath $localModule.Version.ToString()
        "Verifying {0} is running SdnDiagnostics version {1}" -f $($ComputerName -join ', '), $localModule.Version.ToString() | Trace-Output -Level:Verbose

        # make sure that in instances where we might be on a node within the sdn dataplane,
        # that we do not remove the module locally
        foreach ($computer in $ComputerName) {
            if (Test-ComputerNameIsLocal -ComputerName $computer) {
                "Detected that {0} is local machine. Skipping update operation for {0}." -f $computer | Trace-Output -Level:Verbose
                continue
            }

            [void]$filteredComputerName.Add($computer)
        }

        # due to how arrayLists are interpreted, need to check if count is 0 rather than look for $null
        if ($filteredComputerName.Count -eq 0){
            return
        }

        # check to see if the current version is already present on the remote computers
        # else if we -Force defined, we can just move forward
        if ($Force) {
            $installNodes = $filteredComputerName
        }
        else {
            "Getting current installed version of SdnDiagnostics on {0}" -f ($filteredComputerName -join ', ') | Trace-Output -Level:Verbose
            $remoteModuleVersion = Invoke-PSRemoteCommand -ComputerName $filteredComputerName -Credential $Credential -ImportModuleOnRemoteSession:$false -ScriptBlock {
                param ([string]$arg0)
                try {
                    # Get the latest version of SdnDiagnostics Module installed
                    $version = (Get-Module -Name $arg0 -ListAvailable -ErrorAction SilentlyContinue | Sort-Object Version -Descending)[0].Version.ToString()
                }
                catch {
                    # in some instances, the module will not be available and as such we want to skip the noise and return
                    # a string back to the remote call command which we can do proper comparison against
                    $version = '0.0.0.0'
                }
                return $version
            } -ArgumentList @($moduleName)

            # enumerate the versions returned for each computer and compare with current module version to determine if we should perform an update
            foreach ($computer in ($remoteModuleVersion.PSComputerName | Sort-Object -Unique)) {
                $remoteComputerModuleVersions = $remoteModuleVersion | Where-Object {$_.PSComputerName -ieq $computer}
                "{0} is currently using version(s): {1}" -f $computer, ($remoteComputerModuleVersions.ToString() -join ' | ') | Trace-Output -Level:Verbose
                $updateRequired = $true

                foreach ($version in $remoteComputerModuleVersions) {
                    if ([version]$version -ge [version]$localModule.Version) {
                        $updateRequired = $false

                        # if we found a version that is greater or equal to current version, break out of current foreach loop for the versions
                        # and move to the next computer as update is not required
                        break
                    }
                    else {
                        $updateRequired = $true
                    }
                }

                if ($updateRequired) {
                    [void]$installNodes.Add($computer)
                }
            }
        }

        if ($installNodes) {
            "SdnDiagnostics {0} will be installed to {1}" -f $localModule.Version.ToString(), ($filteredComputerName -join ', ') | Trace-Output
            Copy-FileToRemoteComputer -Path $localModule.ModuleBase -ComputerName $installNodes -Destination $destinationPathDir -Credential $Credential -Recurse -Force

            # ensure that we destroy the current pssessions for the computer to prevent any caching issues
            # we will want to remove any existing PSSessions for the remote computers
            Remove-PSRemotingSession -ComputerName $installNodes
        }
        else {
            "No update is required" | Trace-Output -Level:Verbose
        }
    }
    catch {
        "{0}`n{1}" -f $_.Exception, $_.ScriptStackTrace | Trace-Output -Level:Error
    }
}
