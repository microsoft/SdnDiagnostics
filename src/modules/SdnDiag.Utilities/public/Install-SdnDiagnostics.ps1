function Install-SdnDiagnostics {
    <#
    .SYNOPSIS
        Install SdnDiagnostic Module to remote computers if not installed or version mismatch.
    .PARAMETER ComputerName
        Type the NetBIOS name, an IP address, or a fully qualified domain name of one or more remote computers.
    .PARAMETER Credential
        Specifies a user account that has permission to perform this action. The default is the current user.
        Type a user name, such as User01 or Domain01\User01, or enter a PSCredential object generated by the Get-Credential cmdlet. If you type a user name, you're prompted to enter the password.
    #>

    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.String[]]$ComputerName,

        [Parameter(Mandatory = $false)]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty,

        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [System.String]$ModuleRootDir = $Global:SdnDiagnostics.Config.ModuleRootDirectory,

        [Parameter(Mandatory = $false)]
        [switch]$Force
    )

    try {
        # if we are not using the default directory then we need to use the full path to the module
        if ($ModuleRootDir -ine $script:SdnDiagnostics_Utilities.Config.DefaultModuleDirectory) {
            if (-NOT (Split-Path -Path $ModuleRootDir -Leaf) -ieq 'SdnDiagnostics') {
                $moduleName = Join-Path -Path $ModuleRootDir -ChildPath 'SdnDiagnostics'
            }
            else {
                $moduleName = $ModuleRootDir
            }
        }
        else {
            $moduleName = 'SdnDiagnostics'
        }

        $filteredComputerName = [System.Collections.ArrayList]::new()
        $installNodes = [System.Collections.ArrayList]::new()

        # if we have multiple modules installed on the current workstation,
        # abort the operation because side by side modules can cause some interop issues to the remote nodes
        $localModule = Get-Module -Name 'SdnDiagnostics'
        if ($localModule.Count -gt 1) {
            throw "Detected more than one module version of SdnDiagnostics. Remove all versions of module from runspace and re-import the module."
        }

        "Verifying {0} is running SdnDiagnostics version {1}" -f $($ComputerName -join ', '), $localModule.Version.ToString() | Trace-Output

        # module should also be under $ModuleRootDir in a format of $ModuleRootDir\SdnDiagnostics\{version} when using PSGallery version of the module
        # or possibly $ModuleRootDir\SdnDiagnostics if working with dev version of the module
        if ($localModule.ModuleBase -ilike "*\SdnDiagnostics\$($localModule.Version.ToString())") {
            [string]$destinationPathDir = "{0}\{1}\{2}" -f $ModuleRootDir, 'SdnDiagnostics', $localModule.Version.ToString()
        }
        else {
            [string]$destinationPathDir = Join-Path -Path $ModuleRootDir -ChildPath 'SdnDiagnostics'
        }

        # make sure that in instances where we might be on a node within the sdn dataplane,
        # that we do not remove the module locally
        foreach ($computer in $ComputerName) {
            if (Test-ComputerNameIsLocal -ComputerName $computer) {
                "Detected that {0} is local machine. Skipping update operation for {0}." -f $computer | Trace-Output -Level:Warning
                continue
            }

            [void]$filteredComputerName.Add($computer)
        }

        # due to how arrayLists are interpreted, need to check if count is 0 rather than look for $null
        if ($filteredComputerName.Count -eq 0){
            return
        }

        # check to see if the current version is already present on the remote computers
        # else if we -Force defined, we can just move forward
        if ($Force) {
            "{0} will be installed on all computers" -f $localModule.Version.ToString() | Trace-Output
            $installNodes = $filteredComputerName
        }
        else {
            "Getting current installed version of SdnDiagnostics on {0}" -f ($filteredComputerName -join ', ') | Trace-Output -Level:Verbose
            $remoteModuleVersion = Invoke-PSRemoteCommand -ComputerName $filteredComputerName -Credential $Credential -ImportModuleOnRemoteSession:$false -ScriptBlock {
                param ([string]$arg0)
                try {
                    # Get the latest version of SdnDiagnostics Module installed
                    $version = (Get-Module -Name $arg0 -ListAvailable -ErrorAction SilentlyContinue | Sort-Object Version -Descending)[0].Version.ToString()
                }
                catch {
                    # in some instances, the module will not be available and as such we want to skip the noise and return
                    # a string back to the remote call command which we can do proper comparison against
                    $version = '0.0.0.0'
                }
                return $version
            } -ArgumentList @($moduleName)

            # enumerate the versions returned for each computer and compare with current module version to determine if we should perform an update
            foreach ($computer in ($remoteModuleVersion.PSComputerName | Sort-Object -Unique)) {
                $remoteComputerModuleVersions = $remoteModuleVersion | Where-Object {$_.PSComputerName -ieq $computer}
                "{0} is currently using version(s): {1}" -f $computer, ($remoteComputerModuleVersions.ToString() -join ' | ') | Trace-Output -Level:Verbose
                $updateRequired = $true

                foreach ($version in $remoteComputerModuleVersions) {
                    if ([version]$version -ge [version]$localModule.Version) {
                        $updateRequired = $false

                        # if we found a version that is greater or equal to current version, break out of current foreach loop for the versions
                        # and move to the next computer as update is not required
                        break
                    }
                    else {
                        $updateRequired = $true
                    }
                }

                if ($updateRequired) {
                    "{0} will be updated to {1}" -f $computer, $localModule.Version.ToString() | Trace-Output
                    [void]$installNodes.Add($computer)
                }
            }
        }

        if ($installNodes) {
            # we need to ensure we cleanup the remote working directory before we copy the module over
            # this is due to how Copy-Item works as if .\SdnDiagnostics already exists, it will just copy into the folder and not overwrite
            # resulting in structure then of .\SdnDiagnostics\SdnDiagnostics
            Invoke-PSRemoteCommand -ComputerName $installNodes -Credential $Credential -ImportModuleOnRemoteSession:$false -ScriptBlock {
                param ([string]$arg0)
                if (Test-Path -Path $arg0 -PathType Container) {
                    Remove-Item -Path $arg0 -Recurse -Force
                }
            } -ArgumentList @($destinationPathDir)

            Copy-FileToRemoteComputer -Path $localModule.ModuleBase -ComputerName $installNodes -Destination $destinationPathDir -Credential $Credential -Recurse -Force
        }

        # ensure that we destroy the current pssessions for the computer to prevent any caching issues
        # we will want to remove any existing PSSessions for the remote computers
        Remove-PSRemotingSession
    }
    catch {
        "{0}`n{1}" -f $_.Exception, $_.ScriptStackTrace | Trace-Output -Level:Error
    }
}
