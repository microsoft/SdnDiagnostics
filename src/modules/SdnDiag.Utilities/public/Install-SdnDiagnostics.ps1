function Install-SdnDiagnostics {
    <#
    .SYNOPSIS
        Install SdnDiagnostic Module to remote computers if not installed or version mismatch.
    .PARAMETER ComputerName
        Type the NetBIOS name, an IP address, or a fully qualified domain name of one or more remote computers.
    .PARAMETER Credential
        Specifies a user account that has permission to perform this action. The default is the current user.
        Type a user name, such as User01 or Domain01\User01, or enter a PSCredential object generated by the Get-Credential cmdlet. If you type a user name, you're prompted to enter the password.
    .PARAMETER Path
        Specifies the path to the module where it should be installed. If not specified, the default path will be used.
    .PARAMETER Force
        Forces a cleanup and re-install of the module on the remote computer.
    #>

    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.String[]]$ComputerName,

        [Parameter(Mandatory = $false)]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty,

        [Parameter(Mandatory = $false)]
        [System.String]$Path = $Script:SdnDiagnostics_Utilities.Config.DefaultModuleDirectory,

        [Parameter(Mandatory = $false)]
        [switch]$Force
    )

    begin {
        $moduleName = $Global:SdnDiagnostics.Config.ModuleName
        # if we have configured automatic seeding of module to remote nodes, we will want to skip this operation
        if ($Global:SdnDiagnostics.Config.DisableModuleSeeding) {
            return
        }

        # if we have multiple modules installed on the current workstation,
        # abort the operation because side by side modules can cause some interop issues to the remote nodes
        $localModule = Get-Module -Name 'SdnDiagnostics'
        if ($localModule.Count -gt 1) {
            throw "Detected more than one module version of SdnDiagnostics. Remove all versions of module from runspace and re-import the module."
        }

        $getModuleVersionSB = {
            param ([string]$arg0)
            try {
                # Get the latest version of SdnDiagnostics Module installed
                $version = (Get-Module -Name $arg0 -ListAvailable -ErrorAction Ignore | Sort-Object Version -Descending)[0].Version.ToString()
            }
            catch {
                # in some instances, the module will not be available and as such we want to skip the noise and return
                # a string back to the remote call command which we can do proper comparison against
                $version = '0.0.0.0'
            }
            return $version
        }

        # typically PowerShell modules will be installed in the following directory configuration:
        #    $env:ProgramFiles\WindowsPowerShell\Modules\SdnDiagnostics\{version}
        #    $env:USERPROFILE\Documents\WindowsPowerShell\Modules\SdnDiagnostics\{version}
        # so we default to Leaf of the path being SdnDiagnostics as PSGet will handle the versioning so we only ever do import in the following format:
        #    Import-Module SdnDiagnostics (if using default PowerShell module path)
        #    Import-Module C:\{path}\SdnDiagnostics (if using custom PowerShell module path)
        # so we need to ensure that we are copying the module to the correct path on the remote computer
        [System.String]$destinationPathDir = Join-Path $Path -ChildPath $localModule.Version.ToString()
        "Verifying {0} is running SdnDiagnostics version {1}" -f $($ComputerName -join ', '), $localModule.Version.ToString() | Trace-Output -Level:Verbose
    }
    process {
        $ComputerName | ForEach-Object {
            $computer = $_

            try {
                # check to see if the computer is local, if so, we will skip the operation
                if (Test-ComputerNameIsLocal -ComputerName $computer) {
                    "Detected that {0} is local machine. Skipping update operation for {0}." -f $computer | Trace-Output -Level:Verbose
                    return
                }

                if (!$Force) {
                    "Getting current installed version of SdnDiagnostics on {0}" -f $computer | Trace-Output -Level:Verbose

                    # use Invoke-Command here, as we do not want to create a cached session for the remote computers
                    # as it will impact scenarios where we need to import the module on the remote computer for remote sessions
                    try {
                        $remoteModuleVersion = Invoke-Command -ComputerName $computer -Credential $Credential -ScriptBlock $getModuleVersionSB -ArgumentList @($moduleName) -ErrorAction Stop
                    }
                    catch {
                        # if we are unable to connect to the remote computer, we will skip the operation
                        $_ | Trace-Exception
                        "Unable to connect to {0}. Skipping update operation for {0}." -f $computer | Trace-Output -Level:Verbose
                        return
                    }

                    if ($remoteModuleVersion) {
                        # if the remote module version is greater or equal to the local module version, then we do not need to update
                        "{0} is currently using version: {1}" -f $computer, $remoteModuleVersion | Trace-Output -Level:Verbose
                        if ([version]$remoteModuleVersion -ge [version]$localModule.Version) {
                            "No update is required for {0}" -f $computer | Trace-Output -Level:Verbose
                            return
                        }
                    }
                }

                "SdnDiagnostics {0} will be installed to {1}" -f $localModule.Version.ToString(), $computer | Trace-Output
                Copy-FileToRemoteComputer -Path $localModule.ModuleBase -ComputerName $computer -Destination $destinationPathDir -Credential $Credential -Recurse -Force

                # ensure that we destroy the current pssessions for the computer to prevent any caching issues
                # we will want to remove any existing PSSessions for the remote computers
                Remove-PSRemotingSession -ComputerName $computer
            }
            catch {
                $_ | Trace-Exception
                $_ | Write-Error
            }
        }
    }
    end {
        # do nothing here
    }
}
